module TeleHash.Packet
  (
    Packet(..)
  , Head (..)
  , Body(..)
  , newPacket
  , LinePacket(..)
  ) where

import Data.Binary
import Data.Binary.Get
import TeleHash.Convert

import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString.Char8 as BC


{-
HEAD

A length of 0 means there is no HEAD included and the packet is all
binary (only BODY).

A length of 1 means there is a single byte value that is not JSON.

A length of 2+ means the HEAD must be a UTF-8 encoded JSON object or
array (not any bare string/bool/number value). If the JSON parsing
fails, the parser must return an error.
-}

data Head = HeadEmpty | HeadByte Word8 | HeadJson BL.ByteString
          deriving (Show,Eq)

{-
BODY

The optional BODY is always a raw binary of the remainder bytes
between the packet's total length and that of the HEAD.

Often packets are attached inside other packets as the BODY, enabling
simple packet wrapping/relaying usage patterns.

The BODY is also used as the raw content transport for channels and
any app-specific usage.

 -}

type Body = BC.ByteString

data Packet = Packet { paHead :: Head
                     , paBody :: Body
                     }
            deriving Show

newPacket :: Packet
newPacket = Packet { paHead = HeadEmpty
                   , paBody = BC.empty
                   }

-- ---------------------------------------------------------------------

instance Binary Packet where
  put p = do put (paHead p)
             put (paBody p)

  get = do h  <- get
           pb <- getRemainingLazyByteString

           return (newPacket { paHead = h, paBody = lbsTocbs pb})

-- ---------------------------------------------------------------------

instance Binary Head where

  put HeadEmpty    = put (0 :: Word16)
  put (HeadByte b) = do put (1 :: Word16)
                        put b
  put (HeadJson x) = do put ((fromIntegral $ BL.length x) :: Word16)
                        put x

  get = do hb <- get :: Get Word16
           h <- case hb of
                 0 -> return HeadEmpty
                 1 -> do b <- get
                         return (HeadByte b)
                 x -> do b <- getLazyByteString (fromIntegral x)
                         return (HeadJson b)
           return h

-- ---------------------------------------------------------------------

data LinePacket = LP BC.ByteString
                deriving Show

-- ---------------------------------------------------------------------

{-

Examples

First packet out

  This encodes a startup packet of
   {"type":"seek","c":0,"seek":"89a4cbc6c27eb913c1bcaf06bac2d8b872c7cbef626b35b6d7eaf993590d37de"}
-}

p1 :: [Word8]
p1 =
 [
 0x00, 0x01,   -- head length = 1 (BE 16 bit)

 0x1a,         -- Single byte head means 'open' packet, using crypto "1a"

 0x70, 0xf0, 0xd6, 0x5a, 0xc1, 0xae, 0xae, 0x58, 0xe4, 0xaf, 0x0e, 0x58, 0x27,
 0xa4, 0x4b, 0x4b, 0x0b, 0x0d, 0x39, 0x41, 0x15, 0x97, 0xb6, 0x35, 0x55, 0xf0, 0xf0, 0x99, 0x48,
 0xce, 0x81, 0xf5, 0xba, 0xd9, 0xdc, 0x3b, 0x05, 0xc5, 0x81, 0xce, 0x2e, 0x6d, 0xc9, 0x1a, 0xb9,
 0x87, 0xdc, 0xd9, 0x13, 0x44, 0x37, 0xb0, 0x68, 0x25, 0x62, 0xac, 0xc7, 0x07, 0x1e, 0x27, 0xff,
 0xb5, 0x15, 0x64, 0x2e, 0x1a, 0x38, 0xaa, 0x33, 0xe2, 0xaf, 0x1d, 0x74, 0x46, 0xef, 0x89, 0xdc,
 0xa8, 0x15, 0x66, 0x7a, 0x5f, 0xa6, 0x45, 0x9f, 0xbb, 0xdb, 0x7a, 0x27, 0xb5, 0xa9, 0x48, 0xff,
 0xc3, 0xf6, 0xc3, 0x1e, 0xf6, 0x83, 0xf5, 0x1e, 0x06, 0xb4, 0xb3, 0x13, 0xfc, 0x57, 0xa1, 0x2a,
 0xdf, 0x96, 0xdf, 0x90, 0x2d, 0x14, 0x24, 0x11, 0xa6, 0x01, 0x4b, 0xed, 0xf1, 0xd1, 0x32, 0x88,
 0x15, 0xb4, 0x25, 0x0f, 0xa8, 0xda, 0x19, 0xc4, 0xb1, 0xf3, 0xe3, 0x4c, 0x31, 0x4d, 0xfe, 0x36,
 0xcf, 0x76, 0xc8, 0x46, 0x04, 0x30, 0xd2, 0x96, 0x46, 0xec, 0x45, 0xd3, 0x06, 0xb7, 0x92, 0x61,
 0xe8, 0xcf, 0x57, 0xd7, 0x20, 0xc7, 0xf4, 0xcb, 0xab, 0x66, 0x73, 0x39, 0xc5, 0xe4, 0xb4, 0x11,
 0x34, 0xd3, 0x45, 0x4f, 0x06, 0x4e, 0x75, 0xa1, 0xa6, 0x33, 0x91, 0x71, 0x49, 0xeb, 0x6c, 0xd9,
 0x6b, 0xf3, 0x8b, 0x3f, 0x96, 0xe1, 0x2e, 0xad, 0xbc, 0xf0, 0x81, 0x60, 0xae, 0x3d, 0x7d, 0x59,
 0xad, 0x1a, 0x0f, 0xdb, 0x1f, 0xa7, 0x6b, 0x36, 0x24, 0xfc, 0x6a, 0x0c, 0x15, 0xe9, 0x32, 0x64,
 0xe4, 0x55, 0x3f, 0x19, 0xd9, 0x20, 0x4d, 0x80, 0x27, 0x50, 0x68, 0x77, 0x32, 0x27, 0x34, 0x66,
 0xc2, 0x76, 0x02, 0x8f, 0x14, 0xda, 0xe8, 0xfb, 0x89, 0x28, 0x27, 0xfd, 0xbd, 0x8f, 0x41, 0x3f,
 0x71, 0xaa, 0x50, 0xca, 0x21, 0x98, 0x0e, 0x44, 0x69, 0x49, 0xc7, 0x74, 0xf0, 0xa0, 0xc9, 0x0b,
 0x30, 0x8f, 0x99, 0x60, 0x87, 0xec, 0x35, 0x25, 0x0d, 0xeb, 0xa5, 0x0a, 0x29, 0xec, 0x22, 0x13,
 0xae, 0xae, 0xdb, 0x32, 0xf9
 ]

{-
Second packet out
-}

p2 :: [Word8]
p2 =
 [
 0x00, 0x00,  -- head length 0

 0x16, 0x60, 0xef, 0x04, 0x2e, 0x32, 0x1e, 0xfb, 0x11, 0x0d, 0xb8, 0x9f, 0xe7, 0x05,
 0x72, 0xf6, 0x06, 0x48, 0xe2, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf2, 0x87, 0x9e, 0xb5, 0xb2,
 0x4c, 0x3f, 0xf3, 0xca, 0x4c, 0xa3, 0x18, 0xdc, 0x16, 0xac, 0x33, 0x94, 0x9a, 0xaa, 0xcc, 0x01,
 0xdf, 0xb8, 0x16, 0x7f, 0x48, 0xe1, 0x4c, 0xe4, 0x45, 0xa8, 0x4b, 0x61, 0xfa, 0x1e, 0xdb, 0x99,
 0xee, 0x83, 0xdb, 0xb0, 0xbf, 0x83, 0x33, 0x72, 0xbc, 0xf0, 0xbc, 0xfd, 0xda, 0x4a, 0x5c, 0x40,
 0x9d, 0xb6, 0xe1, 0x33, 0x38, 0xc3, 0x9a, 0x54, 0x3e, 0x9e, 0xf6, 0xbe, 0x11, 0x39, 0x2c, 0x0f,
 0x57, 0xb0, 0xc9, 0x27, 0x97, 0x20, 0x8e, 0xf5, 0xf2, 0x38, 0x0a, 0xc1, 0xb9, 0x95, 0xf1, 0xe4,
 0x68, 0x34, 0xd0, 0xc8, 0x55, 0x9b, 0x8a, 0x87, 0xa5, 0xc5, 0xe3
 ]


testp1 = do
  let p1b = BL.pack p1
  let p@(Packet h b) = decode p1b :: Packet
  putStrLn $ show p
  putStrLn $ show (BC.length b)

testp2 = do
  let p1b = BL.pack p2
  let p@(Packet h b) = decode p1b :: Packet
  putStrLn $ show p
  putStrLn $ show (BC.length b)
